{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bezierCurveToPolyline = bezierCurveToPolyline;\nexports.getBezierCurveLength = getBezierCurveLength;\nexports[\"default\"] = void 0;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar sqrt = Math.sqrt,\n  pow = Math.pow,\n  ceil = Math.ceil,\n  abs = Math.abs; // Initialize the number of points per curve\n\nvar defaultSegmentPointsNum = 50;\n/**\r\n * @example data structure of bezierCurve\r\n * bezierCurve = [\r\n *  // Starting point of the curve\r\n *  [10, 10],\r\n *  // BezierCurve segment data (controlPoint1, controlPoint2, endPoint)\r\n *  [\r\n *    [20, 20], [40, 20], [50, 10]\r\n *  ],\r\n *  ...\r\n * ]\r\n */\n\n/**\r\n * @description               Abstract the curve as a polyline consisting of N points\r\n * @param {Array} bezierCurve bezierCurve data\r\n * @param {Number} precision  calculation accuracy. Recommended for 1-20. Default = 5\r\n * @return {Object}           Calculation results and related data\r\n * @return {Array}            Option.segmentPoints Point data that constitutes a polyline after calculation\r\n * @return {Number}           Option.cycles Number of iterations\r\n * @return {Number}           Option.rounds The number of recursions for the last iteration\r\n */\n\nfunction abstractBezierCurveToPolyline(bezierCurve) {\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  var segmentsNum = bezierCurve.length - 1;\n  var startPoint = bezierCurve[0];\n  var endPoint = bezierCurve[segmentsNum][2];\n  var segments = bezierCurve.slice(1);\n  var getSegmentTPointFuns = segments.map(function (seg, i) {\n    var beginPoint = i === 0 ? startPoint : segments[i - 1][2];\n    return createGetBezierCurveTPointFun.apply(void 0, [beginPoint].concat((0, _toConsumableArray2[\"default\"])(seg)));\n  }); // Initialize the curve to a polyline\n\n  var segmentPointsNum = new Array(segmentsNum).fill(defaultSegmentPointsNum);\n  var segmentPoints = getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum); // Calculate uniformly distributed points by iteratively\n\n  var result = calcUniformPointsByIteration(segmentPoints, getSegmentTPointFuns, segments, precision);\n  result.segmentPoints.push(endPoint);\n  return result;\n}\n/**\r\n * @description  Generate a method for obtaining corresponding point by t according to curve data\r\n * @param {Array} beginPoint    BezierCurve begin point. [x, y]\r\n * @param {Array} controlPoint1 BezierCurve controlPoint1. [x, y]\r\n * @param {Array} controlPoint2 BezierCurve controlPoint2. [x, y]\r\n * @param {Array} endPoint      BezierCurve end point. [x, y]\r\n * @return {Function} Expected function\r\n */\n\nfunction createGetBezierCurveTPointFun(beginPoint, controlPoint1, controlPoint2, endPoint) {\n  return function (t) {\n    var tSubed1 = 1 - t;\n    var tSubed1Pow3 = pow(tSubed1, 3);\n    var tSubed1Pow2 = pow(tSubed1, 2);\n    var tPow3 = pow(t, 3);\n    var tPow2 = pow(t, 2);\n    return [beginPoint[0] * tSubed1Pow3 + 3 * controlPoint1[0] * t * tSubed1Pow2 + 3 * controlPoint2[0] * tPow2 * tSubed1 + endPoint[0] * tPow3, beginPoint[1] * tSubed1Pow3 + 3 * controlPoint1[1] * t * tSubed1Pow2 + 3 * controlPoint2[1] * tPow2 * tSubed1 + endPoint[1] * tPow3];\n  };\n}\n/**\r\n * @description Get the distance between two points\r\n * @param {Array} point1 BezierCurve begin point. [x, y]\r\n * @param {Array} point2 BezierCurve controlPoint1. [x, y]\r\n * @return {Number} Expected distance\r\n */\n\nfunction getTwoPointDistance(_ref, _ref2) {\n  var _ref3 = (0, _slicedToArray2[\"default\"])(_ref, 2),\n    ax = _ref3[0],\n    ay = _ref3[1];\n  var _ref4 = (0, _slicedToArray2[\"default\"])(_ref2, 2),\n    bx = _ref4[0],\n    by = _ref4[1];\n  return sqrt(pow(ax - bx, 2) + pow(ay - by, 2));\n}\n/**\r\n * @description Get the sum of the array of numbers\r\n * @param {Array} nums An array of numbers\r\n * @return {Number} Expected sum\r\n */\n\nfunction getNumsSum(nums) {\n  return nums.reduce(function (sum, num) {\n    return sum + num;\n  }, 0);\n}\n/**\r\n * @description Get the distance of multiple sets of points\r\n * @param {Array} segmentPoints Multiple sets of point data\r\n * @return {Array} Distance of multiple sets of point data\r\n */\n\nfunction getSegmentPointsDistance(segmentPoints) {\n  return segmentPoints.map(function (points, i) {\n    return new Array(points.length - 1).fill(0).map(function (temp, j) {\n      return getTwoPointDistance(points[j], points[j + 1]);\n    });\n  });\n}\n/**\r\n * @description Get the distance of multiple sets of points\r\n * @param {Array} segmentPoints Multiple sets of point data\r\n * @return {Array} Distance of multiple sets of point data\r\n */\n\nfunction getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum) {\n  return getSegmentTPointFuns.map(function (getSegmentTPointFun, i) {\n    var tGap = 1 / segmentPointsNum[i];\n    return new Array(segmentPointsNum[i]).fill('').map(function (foo, j) {\n      return getSegmentTPointFun(j * tGap);\n    });\n  });\n}\n/**\r\n * @description Get the sum of deviations between line segment and the average length\r\n * @param {Array} segmentPointsDistance Segment length of polyline\r\n * @param {Number} avgLength            Average length of the line segment\r\n * @return {Number} Deviations\r\n */\n\nfunction getAllDeviations(segmentPointsDistance, avgLength) {\n  return segmentPointsDistance.map(function (seg) {\n    return seg.map(function (s) {\n      return abs(s - avgLength);\n    });\n  }).map(function (seg) {\n    return getNumsSum(seg);\n  }).reduce(function (total, v) {\n    return total + v;\n  }, 0);\n}\n/**\r\n * @description Calculate uniformly distributed points by iteratively\r\n * @param {Array} segmentPoints        Multiple setd of points that make up a polyline\r\n * @param {Array} getSegmentTPointFuns Functions of get a point on the curve with t\r\n * @param {Array} segments             BezierCurve data\r\n * @param {Number} precision           Calculation accuracy\r\n * @return {Object} Calculation results and related data\r\n * @return {Array}  Option.segmentPoints Point data that constitutes a polyline after calculation\r\n * @return {Number} Option.cycles Number of iterations\r\n * @return {Number} Option.rounds The number of recursions for the last iteration\r\n */\n\nfunction calcUniformPointsByIteration(segmentPoints, getSegmentTPointFuns, segments, precision) {\n  // The number of loops for the current iteration\n  var rounds = 4; // Number of iterations\n\n  var cycles = 1;\n  var _loop = function _loop() {\n    // Recalculate the number of points per curve based on the last iteration data\n    var totalPointsNum = segmentPoints.reduce(function (total, seg) {\n      return total + seg.length;\n    }, 0); // Add last points of segment to calc exact segment length\n\n    segmentPoints.forEach(function (seg, i) {\n      return seg.push(segments[i][2]);\n    });\n    var segmentPointsDistance = getSegmentPointsDistance(segmentPoints);\n    var lineSegmentNum = segmentPointsDistance.reduce(function (total, seg) {\n      return total + seg.length;\n    }, 0);\n    var segmentlength = segmentPointsDistance.map(function (seg) {\n      return getNumsSum(seg);\n    });\n    var totalLength = getNumsSum(segmentlength);\n    var avgLength = totalLength / lineSegmentNum; // Check if precision is reached\n\n    var allDeviations = getAllDeviations(segmentPointsDistance, avgLength);\n    if (allDeviations <= precision) return \"break\";\n    totalPointsNum = ceil(avgLength / precision * totalPointsNum * 1.1);\n    var segmentPointsNum = segmentlength.map(function (length) {\n      return ceil(length / totalLength * totalPointsNum);\n    }); // Calculate the points after redistribution\n\n    segmentPoints = getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum);\n    totalPointsNum = segmentPoints.reduce(function (total, seg) {\n      return total + seg.length;\n    }, 0);\n    var segmentPointsForLength = JSON.parse(JSON.stringify(segmentPoints));\n    segmentPointsForLength.forEach(function (seg, i) {\n      return seg.push(segments[i][2]);\n    });\n    segmentPointsDistance = getSegmentPointsDistance(segmentPointsForLength);\n    lineSegmentNum = segmentPointsDistance.reduce(function (total, seg) {\n      return total + seg.length;\n    }, 0);\n    segmentlength = segmentPointsDistance.map(function (seg) {\n      return getNumsSum(seg);\n    });\n    totalLength = getNumsSum(segmentlength);\n    avgLength = totalLength / lineSegmentNum;\n    var stepSize = 1 / totalPointsNum / 10; // Recursively for each segment of the polyline\n\n    getSegmentTPointFuns.forEach(function (getSegmentTPointFun, i) {\n      var currentSegmentPointsNum = segmentPointsNum[i];\n      var t = new Array(currentSegmentPointsNum).fill('').map(function (foo, j) {\n        return j / segmentPointsNum[i];\n      }); // Repeated recursive offset\n\n      for (var r = 0; r < rounds; r++) {\n        var distance = getSegmentPointsDistance([segmentPoints[i]])[0];\n        var deviations = distance.map(function (d) {\n          return d - avgLength;\n        });\n        var offset = 0;\n        for (var j = 0; j < currentSegmentPointsNum; j++) {\n          if (j === 0) return;\n          offset += deviations[j - 1];\n          t[j] -= stepSize * offset;\n          if (t[j] > 1) t[j] = 1;\n          if (t[j] < 0) t[j] = 0;\n          segmentPoints[i][j] = getSegmentTPointFun(t[j]);\n        }\n      }\n    });\n    rounds *= 4;\n    cycles++;\n  };\n  do {\n    var _ret = _loop();\n    if (_ret === \"break\") break;\n  } while (rounds <= 1025);\n  segmentPoints = segmentPoints.reduce(function (all, seg) {\n    return all.concat(seg);\n  }, []);\n  return {\n    segmentPoints: segmentPoints,\n    cycles: cycles,\n    rounds: rounds\n  };\n}\n/**\r\n * @description Get the polyline corresponding to the Bezier curve\r\n * @param {Array} bezierCurve BezierCurve data\r\n * @param {Number} precision  Calculation accuracy. Recommended for 1-20. Default = 5\r\n * @return {Array|Boolean} Point data that constitutes a polyline after calculation (Invalid input will return false)\r\n */\n\nfunction bezierCurveToPolyline(bezierCurve) {\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  if (!bezierCurve) {\n    console.error('bezierCurveToPolyline: Missing parameters!');\n    return false;\n  }\n  if (!(bezierCurve instanceof Array)) {\n    console.error('bezierCurveToPolyline: Parameter bezierCurve must be an array!');\n    return false;\n  }\n  if (typeof precision !== 'number') {\n    console.error('bezierCurveToPolyline: Parameter precision must be a number!');\n    return false;\n  }\n  var _abstractBezierCurveT = abstractBezierCurveToPolyline(bezierCurve, precision),\n    segmentPoints = _abstractBezierCurveT.segmentPoints;\n  return segmentPoints;\n}\n/**\r\n * @description Get the bezier curve length\r\n * @param {Array} bezierCurve bezierCurve data\r\n * @param {Number} precision  calculation accuracy. Recommended for 5-10. Default = 5\r\n * @return {Number|Boolean} BezierCurve length (Invalid input will return false)\r\n */\n\nfunction getBezierCurveLength(bezierCurve) {\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  if (!bezierCurve) {\n    console.error('getBezierCurveLength: Missing parameters!');\n    return false;\n  }\n  if (!(bezierCurve instanceof Array)) {\n    console.error('getBezierCurveLength: Parameter bezierCurve must be an array!');\n    return false;\n  }\n  if (typeof precision !== 'number') {\n    console.error('getBezierCurveLength: Parameter precision must be a number!');\n    return false;\n  }\n  var _abstractBezierCurveT2 = abstractBezierCurveToPolyline(bezierCurve, precision),\n    segmentPoints = _abstractBezierCurveT2.segmentPoints; // Calculate the total length of the points that make up the polyline\n\n  var pointsDistance = getSegmentPointsDistance([segmentPoints])[0];\n  var length = getNumsSum(pointsDistance);\n  return length;\n}\nvar _default = bezierCurveToPolyline;\nexports[\"default\"] = _default;","map":{"version":3,"names":["require","_interopRequireDefault","Object","defineProperty","exports","value","bezierCurveToPolyline","getBezierCurveLength","_slicedToArray2","_toConsumableArray2","sqrt","Math","pow","ceil","abs","defaultSegmentPointsNum","abstractBezierCurveToPolyline","bezierCurve","precision","arguments","length","undefined","segmentsNum","startPoint","endPoint","segments","slice","getSegmentTPointFuns","map","seg","i","beginPoint","createGetBezierCurveTPointFun","apply","concat","segmentPointsNum","Array","fill","segmentPoints","getSegmentPointsByNum","result","calcUniformPointsByIteration","push","controlPoint1","controlPoint2","t","tSubed1","tSubed1Pow3","tSubed1Pow2","tPow3","tPow2","getTwoPointDistance","_ref","_ref2","_ref3","ax","ay","_ref4","bx","by","getNumsSum","nums","reduce","sum","num","getSegmentPointsDistance","points","temp","j","getSegmentTPointFun","tGap","foo","getAllDeviations","segmentPointsDistance","avgLength","s","total","v","rounds","cycles","_loop","totalPointsNum","forEach","lineSegmentNum","segmentlength","totalLength","allDeviations","segmentPointsForLength","JSON","parse","stringify","stepSize","currentSegmentPointsNum","r","distance","deviations","d","offset","_ret","all","console","error","_abstractBezierCurveT","_abstractBezierCurveT2","pointsDistance","_default"],"sources":["F:/vue_workspace/management_front_end/node_modules/@jiaminghi/bezier-curve/lib/core/bezierCurveToPolyline.js"],"sourcesContent":["\"use strict\";\r\n\r\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.bezierCurveToPolyline = bezierCurveToPolyline;\r\nexports.getBezierCurveLength = getBezierCurveLength;\r\nexports[\"default\"] = void 0;\r\n\r\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\r\n\r\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\r\n\r\nvar sqrt = Math.sqrt,\r\n    pow = Math.pow,\r\n    ceil = Math.ceil,\r\n    abs = Math.abs; // Initialize the number of points per curve\r\n\r\nvar defaultSegmentPointsNum = 50;\r\n/**\r\n * @example data structure of bezierCurve\r\n * bezierCurve = [\r\n *  // Starting point of the curve\r\n *  [10, 10],\r\n *  // BezierCurve segment data (controlPoint1, controlPoint2, endPoint)\r\n *  [\r\n *    [20, 20], [40, 20], [50, 10]\r\n *  ],\r\n *  ...\r\n * ]\r\n */\r\n\r\n/**\r\n * @description               Abstract the curve as a polyline consisting of N points\r\n * @param {Array} bezierCurve bezierCurve data\r\n * @param {Number} precision  calculation accuracy. Recommended for 1-20. Default = 5\r\n * @return {Object}           Calculation results and related data\r\n * @return {Array}            Option.segmentPoints Point data that constitutes a polyline after calculation\r\n * @return {Number}           Option.cycles Number of iterations\r\n * @return {Number}           Option.rounds The number of recursions for the last iteration\r\n */\r\n\r\nfunction abstractBezierCurveToPolyline(bezierCurve) {\r\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\r\n  var segmentsNum = bezierCurve.length - 1;\r\n  var startPoint = bezierCurve[0];\r\n  var endPoint = bezierCurve[segmentsNum][2];\r\n  var segments = bezierCurve.slice(1);\r\n  var getSegmentTPointFuns = segments.map(function (seg, i) {\r\n    var beginPoint = i === 0 ? startPoint : segments[i - 1][2];\r\n    return createGetBezierCurveTPointFun.apply(void 0, [beginPoint].concat((0, _toConsumableArray2[\"default\"])(seg)));\r\n  }); // Initialize the curve to a polyline\r\n\r\n  var segmentPointsNum = new Array(segmentsNum).fill(defaultSegmentPointsNum);\r\n  var segmentPoints = getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum); // Calculate uniformly distributed points by iteratively\r\n\r\n  var result = calcUniformPointsByIteration(segmentPoints, getSegmentTPointFuns, segments, precision);\r\n  result.segmentPoints.push(endPoint);\r\n  return result;\r\n}\r\n/**\r\n * @description  Generate a method for obtaining corresponding point by t according to curve data\r\n * @param {Array} beginPoint    BezierCurve begin point. [x, y]\r\n * @param {Array} controlPoint1 BezierCurve controlPoint1. [x, y]\r\n * @param {Array} controlPoint2 BezierCurve controlPoint2. [x, y]\r\n * @param {Array} endPoint      BezierCurve end point. [x, y]\r\n * @return {Function} Expected function\r\n */\r\n\r\n\r\nfunction createGetBezierCurveTPointFun(beginPoint, controlPoint1, controlPoint2, endPoint) {\r\n  return function (t) {\r\n    var tSubed1 = 1 - t;\r\n    var tSubed1Pow3 = pow(tSubed1, 3);\r\n    var tSubed1Pow2 = pow(tSubed1, 2);\r\n    var tPow3 = pow(t, 3);\r\n    var tPow2 = pow(t, 2);\r\n    return [beginPoint[0] * tSubed1Pow3 + 3 * controlPoint1[0] * t * tSubed1Pow2 + 3 * controlPoint2[0] * tPow2 * tSubed1 + endPoint[0] * tPow3, beginPoint[1] * tSubed1Pow3 + 3 * controlPoint1[1] * t * tSubed1Pow2 + 3 * controlPoint2[1] * tPow2 * tSubed1 + endPoint[1] * tPow3];\r\n  };\r\n}\r\n/**\r\n * @description Get the distance between two points\r\n * @param {Array} point1 BezierCurve begin point. [x, y]\r\n * @param {Array} point2 BezierCurve controlPoint1. [x, y]\r\n * @return {Number} Expected distance\r\n */\r\n\r\n\r\nfunction getTwoPointDistance(_ref, _ref2) {\r\n  var _ref3 = (0, _slicedToArray2[\"default\"])(_ref, 2),\r\n      ax = _ref3[0],\r\n      ay = _ref3[1];\r\n\r\n  var _ref4 = (0, _slicedToArray2[\"default\"])(_ref2, 2),\r\n      bx = _ref4[0],\r\n      by = _ref4[1];\r\n\r\n  return sqrt(pow(ax - bx, 2) + pow(ay - by, 2));\r\n}\r\n/**\r\n * @description Get the sum of the array of numbers\r\n * @param {Array} nums An array of numbers\r\n * @return {Number} Expected sum\r\n */\r\n\r\n\r\nfunction getNumsSum(nums) {\r\n  return nums.reduce(function (sum, num) {\r\n    return sum + num;\r\n  }, 0);\r\n}\r\n/**\r\n * @description Get the distance of multiple sets of points\r\n * @param {Array} segmentPoints Multiple sets of point data\r\n * @return {Array} Distance of multiple sets of point data\r\n */\r\n\r\n\r\nfunction getSegmentPointsDistance(segmentPoints) {\r\n  return segmentPoints.map(function (points, i) {\r\n    return new Array(points.length - 1).fill(0).map(function (temp, j) {\r\n      return getTwoPointDistance(points[j], points[j + 1]);\r\n    });\r\n  });\r\n}\r\n/**\r\n * @description Get the distance of multiple sets of points\r\n * @param {Array} segmentPoints Multiple sets of point data\r\n * @return {Array} Distance of multiple sets of point data\r\n */\r\n\r\n\r\nfunction getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum) {\r\n  return getSegmentTPointFuns.map(function (getSegmentTPointFun, i) {\r\n    var tGap = 1 / segmentPointsNum[i];\r\n    return new Array(segmentPointsNum[i]).fill('').map(function (foo, j) {\r\n      return getSegmentTPointFun(j * tGap);\r\n    });\r\n  });\r\n}\r\n/**\r\n * @description Get the sum of deviations between line segment and the average length\r\n * @param {Array} segmentPointsDistance Segment length of polyline\r\n * @param {Number} avgLength            Average length of the line segment\r\n * @return {Number} Deviations\r\n */\r\n\r\n\r\nfunction getAllDeviations(segmentPointsDistance, avgLength) {\r\n  return segmentPointsDistance.map(function (seg) {\r\n    return seg.map(function (s) {\r\n      return abs(s - avgLength);\r\n    });\r\n  }).map(function (seg) {\r\n    return getNumsSum(seg);\r\n  }).reduce(function (total, v) {\r\n    return total + v;\r\n  }, 0);\r\n}\r\n/**\r\n * @description Calculate uniformly distributed points by iteratively\r\n * @param {Array} segmentPoints        Multiple setd of points that make up a polyline\r\n * @param {Array} getSegmentTPointFuns Functions of get a point on the curve with t\r\n * @param {Array} segments             BezierCurve data\r\n * @param {Number} precision           Calculation accuracy\r\n * @return {Object} Calculation results and related data\r\n * @return {Array}  Option.segmentPoints Point data that constitutes a polyline after calculation\r\n * @return {Number} Option.cycles Number of iterations\r\n * @return {Number} Option.rounds The number of recursions for the last iteration\r\n */\r\n\r\n\r\nfunction calcUniformPointsByIteration(segmentPoints, getSegmentTPointFuns, segments, precision) {\r\n  // The number of loops for the current iteration\r\n  var rounds = 4; // Number of iterations\r\n\r\n  var cycles = 1;\r\n\r\n  var _loop = function _loop() {\r\n    // Recalculate the number of points per curve based on the last iteration data\r\n    var totalPointsNum = segmentPoints.reduce(function (total, seg) {\r\n      return total + seg.length;\r\n    }, 0); // Add last points of segment to calc exact segment length\r\n\r\n    segmentPoints.forEach(function (seg, i) {\r\n      return seg.push(segments[i][2]);\r\n    });\r\n    var segmentPointsDistance = getSegmentPointsDistance(segmentPoints);\r\n    var lineSegmentNum = segmentPointsDistance.reduce(function (total, seg) {\r\n      return total + seg.length;\r\n    }, 0);\r\n    var segmentlength = segmentPointsDistance.map(function (seg) {\r\n      return getNumsSum(seg);\r\n    });\r\n    var totalLength = getNumsSum(segmentlength);\r\n    var avgLength = totalLength / lineSegmentNum; // Check if precision is reached\r\n\r\n    var allDeviations = getAllDeviations(segmentPointsDistance, avgLength);\r\n    if (allDeviations <= precision) return \"break\";\r\n    totalPointsNum = ceil(avgLength / precision * totalPointsNum * 1.1);\r\n    var segmentPointsNum = segmentlength.map(function (length) {\r\n      return ceil(length / totalLength * totalPointsNum);\r\n    }); // Calculate the points after redistribution\r\n\r\n    segmentPoints = getSegmentPointsByNum(getSegmentTPointFuns, segmentPointsNum);\r\n    totalPointsNum = segmentPoints.reduce(function (total, seg) {\r\n      return total + seg.length;\r\n    }, 0);\r\n    var segmentPointsForLength = JSON.parse(JSON.stringify(segmentPoints));\r\n    segmentPointsForLength.forEach(function (seg, i) {\r\n      return seg.push(segments[i][2]);\r\n    });\r\n    segmentPointsDistance = getSegmentPointsDistance(segmentPointsForLength);\r\n    lineSegmentNum = segmentPointsDistance.reduce(function (total, seg) {\r\n      return total + seg.length;\r\n    }, 0);\r\n    segmentlength = segmentPointsDistance.map(function (seg) {\r\n      return getNumsSum(seg);\r\n    });\r\n    totalLength = getNumsSum(segmentlength);\r\n    avgLength = totalLength / lineSegmentNum;\r\n    var stepSize = 1 / totalPointsNum / 10; // Recursively for each segment of the polyline\r\n\r\n    getSegmentTPointFuns.forEach(function (getSegmentTPointFun, i) {\r\n      var currentSegmentPointsNum = segmentPointsNum[i];\r\n      var t = new Array(currentSegmentPointsNum).fill('').map(function (foo, j) {\r\n        return j / segmentPointsNum[i];\r\n      }); // Repeated recursive offset\r\n\r\n      for (var r = 0; r < rounds; r++) {\r\n        var distance = getSegmentPointsDistance([segmentPoints[i]])[0];\r\n        var deviations = distance.map(function (d) {\r\n          return d - avgLength;\r\n        });\r\n        var offset = 0;\r\n\r\n        for (var j = 0; j < currentSegmentPointsNum; j++) {\r\n          if (j === 0) return;\r\n          offset += deviations[j - 1];\r\n          t[j] -= stepSize * offset;\r\n          if (t[j] > 1) t[j] = 1;\r\n          if (t[j] < 0) t[j] = 0;\r\n          segmentPoints[i][j] = getSegmentTPointFun(t[j]);\r\n        }\r\n      }\r\n    });\r\n    rounds *= 4;\r\n    cycles++;\r\n  };\r\n\r\n  do {\r\n    var _ret = _loop();\r\n\r\n    if (_ret === \"break\") break;\r\n  } while (rounds <= 1025);\r\n\r\n  segmentPoints = segmentPoints.reduce(function (all, seg) {\r\n    return all.concat(seg);\r\n  }, []);\r\n  return {\r\n    segmentPoints: segmentPoints,\r\n    cycles: cycles,\r\n    rounds: rounds\r\n  };\r\n}\r\n/**\r\n * @description Get the polyline corresponding to the Bezier curve\r\n * @param {Array} bezierCurve BezierCurve data\r\n * @param {Number} precision  Calculation accuracy. Recommended for 1-20. Default = 5\r\n * @return {Array|Boolean} Point data that constitutes a polyline after calculation (Invalid input will return false)\r\n */\r\n\r\n\r\nfunction bezierCurveToPolyline(bezierCurve) {\r\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\r\n\r\n  if (!bezierCurve) {\r\n    console.error('bezierCurveToPolyline: Missing parameters!');\r\n    return false;\r\n  }\r\n\r\n  if (!(bezierCurve instanceof Array)) {\r\n    console.error('bezierCurveToPolyline: Parameter bezierCurve must be an array!');\r\n    return false;\r\n  }\r\n\r\n  if (typeof precision !== 'number') {\r\n    console.error('bezierCurveToPolyline: Parameter precision must be a number!');\r\n    return false;\r\n  }\r\n\r\n  var _abstractBezierCurveT = abstractBezierCurveToPolyline(bezierCurve, precision),\r\n      segmentPoints = _abstractBezierCurveT.segmentPoints;\r\n\r\n  return segmentPoints;\r\n}\r\n/**\r\n * @description Get the bezier curve length\r\n * @param {Array} bezierCurve bezierCurve data\r\n * @param {Number} precision  calculation accuracy. Recommended for 5-10. Default = 5\r\n * @return {Number|Boolean} BezierCurve length (Invalid input will return false)\r\n */\r\n\r\n\r\nfunction getBezierCurveLength(bezierCurve) {\r\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\r\n\r\n  if (!bezierCurve) {\r\n    console.error('getBezierCurveLength: Missing parameters!');\r\n    return false;\r\n  }\r\n\r\n  if (!(bezierCurve instanceof Array)) {\r\n    console.error('getBezierCurveLength: Parameter bezierCurve must be an array!');\r\n    return false;\r\n  }\r\n\r\n  if (typeof precision !== 'number') {\r\n    console.error('getBezierCurveLength: Parameter precision must be a number!');\r\n    return false;\r\n  }\r\n\r\n  var _abstractBezierCurveT2 = abstractBezierCurveToPolyline(bezierCurve, precision),\r\n      segmentPoints = _abstractBezierCurveT2.segmentPoints; // Calculate the total length of the points that make up the polyline\r\n\r\n\r\n  var pointsDistance = getSegmentPointsDistance([segmentPoints])[0];\r\n  var length = getNumsSum(pointsDistance);\r\n  return length;\r\n}\r\n\r\nvar _default = bezierCurveToPolyline;\r\nexports[\"default\"] = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}